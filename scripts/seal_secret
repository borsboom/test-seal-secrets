#!/usr/bin/env bash
#@@@ REMOVE THIS FILE
#
# Encrypt a secret using Bitnami Sealed Secrets.  The encrypted file can only
# be decrypted by the Kubernetes cluster, so it is safe to commit to the Git
# repository and add as a resource in the 'kustomization.yaml'.  See Bitnami
# Sealed Secrets documentation for more background:
# https://github.com/bitnami-labs/sealed-secrets/blob/main/README.md
#
# Usage:
#
#   scripts/seal_secret SECRET_NAME [CREATE SECRET ARGS]
#
# Arguments:
#
#   - SECRET_NAME: the name of the sealed secret to create or update
#
#   - CREATE SECRET ARGS: arguments such as '--from-literal' and '--from-file'
#     that are used to create the input secret manifest.  See output of
#     'kubectl create secret generic -h' for more information.
#
# Prerequisites:
#
#   - 'kubeseal' CLI, which can be installed by following instructions at
#     https://github.com/bitnami-labs/sealed-secrets/releases/latest
#
#   - 'kubectl' CLI, which can be installed by following instructions at
#     https://kubernetes.io/docs/tasks/tools/#kubectl
#
# Notes:
#
#   - You must run this script with the current directory in one of the
#     environment overlay directories (e.g.
#     kubernetes/billing-webapi/overlays/dev).
#
#   - This script will create or update a file named
#     '<SECRET_NAME>_sealedsecret.yaml' which can be committed to the Git
#     repository.
#
#   - If CREATE SECRET ARGS are not specified, this script will expect a secret
#     manifest to seal on standard input.
#
#   - If the sealed secret output file already exists, any new keys will be
#     merged into the existing secret.  To create a new sealed secret from
#     scratch, delete the output file first.
#
# Examples:
#
#   - Create a new secret with field 'foo':
#
#     ../../../../scripts/seal_secret mysecret --from-literal foo=bar
#
#   - Add another 'bar' field to the secret:
#
#     ../../../../scripts/seal_secret mysecret --from-literal baz=quux
#     e.g. ../../../../scripts/seal_secret operatorservices-webapi-variables --from-literal AzureEventGrid__BillingExportTopicSettings__CredentialKey=<value>
#
#   - Replace the value of the 'foo' field with what is typed from standard
#     input:
#
#     ../../../../scripts/seal_secret mysecret --from-file foo=/dev/stdin
#

set -eu -o pipefail
NAMESPACE="$(basename "$(cd "$(dirname "$0")/.."; pwd)")"; NAMESPACE="${NAMESPACE%-envs}"; NAMESPACE="${NAMESPACE%-env}"

if [[ "$#" -lt 1 ]]; then
    echo "$(basename "$0"): Invalid arguments; see header of this script for usage information." >&2
    exit 1
fi
SECRET_NAME="$1"
shift

env_basename="$(basename "$PWD")"
if [[ "$env_basename" == "templates" ]]; then
    env_basename="$(basename "$(dirname "$PWD")")"
fi
env=${env_basename##*[-_]}

cert_path="$(dirname "$0")/data/${env}_sealedsecrets.crt"
if [[ ! -s "$cert_path" ]]; then
    echo "$(basename "$0"): No certificate found for '$env' environment." >&2
    echo "Ensure that you are in an environment overlay directory." >&2
    exit 1
fi

dest_filename="${SECRET_NAME}_sealedsecret.yaml"

if ! (which kubectl >/dev/null) && [[ "$#" -ge 1 ]]; then
    echo "$(basename "$0"): You must install the 'kubectl' CLI; see header of this script for more information." >&2
    exit 1
fi

if ! (which kubeseal >/dev/null); then
    echo "$(basename "$0"): You must install the 'kubeseal' CLI; see header of this script for more information." >&2
    exit 1
fi

if [[ -s "$dest_filename" ]]; then
    if [[ "$#" -lt 1 ]]; then
        (set -x; kubeseal --namespace "${NAMESPACE}" --scope namespace-wide --cert "$cert_path" -o yaml --merge-into "$dest_filename"
        )
    else
        (set -x; kubectl create secret generic "$SECRET_NAME" --dry-run=client -o yaml "$@" \
            | kubeseal --namespace "${NAMESPACE}" --scope namespace-wide --cert "$cert_path" -o yaml --merge-into "$dest_filename"
        )
    fi
    echo >&2
    echo "$(basename "$0"): Updated sealed secret in file: $dest_filename"
else
    trap 'rm -f "${dest_filename}.tmp"' EXIT
    if [[ "$#" -lt 1 ]]; then
        (set -x; kubeseal --namespace "${NAMESPACE}" --scope namespace-wide --cert "$cert_path" -o yaml >"${dest_filename}.tmp"
        )
    else
        (set -x; \
            kubectl create secret generic "$SECRET_NAME" --dry-run=client -o yaml "$@" \
            | kubeseal --namespace "${NAMESPACE}" --scope namespace-wide --cert "$cert_path" -o yaml >"${dest_filename}.tmp" \
        )
    fi
    mv "${dest_filename}.tmp" "$dest_filename"
    echo >&2
    echo "$(basename "$0"): Created sealed secret in file: $dest_filename"
fi
